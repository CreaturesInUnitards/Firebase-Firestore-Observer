<!DOCTYPE html>
<html lang="en">
<head>
	<script src="https://www.gstatic.com/firebasejs/4.9.0/firebase.js"></script>
	<script src="https://www.gstatic.com/firebasejs/4.9.0/firebase-firestore.js"></script>
	<script>
		/***********************************************************************/
		/******************     YOUR FIREBASE STUFF HERE     *******************/
		/***********************************************************************/

		firebase.initializeApp({
			apiKey: "YOUR_API_KEY",
			authDomain: "YOUR_AUTH_DOMAIN",
			projectId: "YOUR_PROJECT_ID"
		})

		/***********************************************************************/
		/***********************************************************************/
		/***********************************************************************/
	</script>
	<meta charset="UTF-8">
	<title>firebase POC</title>
	<style>
		body { padding: 50px }
		#wrapper { display: flex; justify-content: center; flex-wrap: wrap }
		.app { padding: 20px; border: 1px solid black; margin: 20px }
		h2 { text-align: center }
	</style>
</head>
<body>
	<div id="wrapper">
		<div class="app" id="mithril"></div>
		<div class="app" id="react"></div>
		<div class="app" id="vanilla"></div>
	</div>
	<script src="https://unpkg.com/mithril@1.1.6/mithril.min.js"></script>
	<script src="https://unpkg.com/react@16.0.0/umd/react.production.min.js"></script>
	<script src="https://unpkg.com/react-dom@16.0.0/umd/react-dom.production.min.js"></script>
	<script src="https://unpkg.com/babel-standalone@6.26.0/babel.min.js"></script>
	<script type="text/babel">
		const FBObserve = (collectionName, target, options) => {
			const targetObj = typeof target.FBLocalObject == 'undefined' ? target : target.FBLocalObject
			const prop = target.FBLocalProp
			if (target.FBLocalObject && !prop) throw new Error('FBObserver received FBLocalObject without FBLocalProp.')

			const redraw = options.redrawFn ? options.redrawFn : typeof m != 'undefined' ? m.redraw : () => { 
				throw new Error("FBObserver needs a valid redraw function")
			}

			const condition = options.condition
			const crudFn = options.crudFn || crud

			const coll = firebase.firestore().collection(collectionName)
			const ref = condition ? coll.where(condition[0], condition[1], condition[2]) : coll

			ref.onSnapshot((snap) => {
				snap.docChanges.forEach((change) => {
					(new Promise((resolve) => { (crudFn || crud)(change).then(resolve) }))
						.then(redraw)
						.catch((e) => console.log(e, 'Your CRUD function must return a promise.'))
				})
			})

			function crud(change) {
				const id = change.doc.id
				const data = change.doc.data()
				const isArray = Array.isArray(targetObj)
				const existing = isArray ? targetObj.find((obj) => obj.id === id) : targetObj[id]

				switch(change.type) {
					case 'added':
						const o = {id: id, data: data}
						if (isArray) targetObj.push(o)
						else targetObj[prop || id] = o
						break
					case 'modified': {
						if (existing) {
							existing.data = data
							break
						}
					}
					case 'removed': {
						if (existing) {
							if (isArray) targetObj.splice(targetObj.indexOf(existing), 1)
							else delete existing
						}
					}
				}
				return new Promise(r => r()).then(options.callback)
			}
		}


		const State = {
			things: [],
			sortThings: () => State.things.sort((a, b) => a.data.timestamp < b.data.timestamp ? -1 : a.data.timestamp > b.data.timestamp ? 1 : 0),
			existingThing: (key) => State.things.find((thing) => thing.key === key),
			addThing: () => firebase.firestore().collection('Things')
				.add({ name: 'new thing', timestamp: Date.now() })
				.catch((e) => console.log('error', e)),
			removeThing: (id) => {
				if (confirm(`Delete thing ${key}?`)) {
					firebase.firestore().collection('Things').doc(id)
						.delete()
						.catch((e) => console.log("error deleting ", id))
				}
			},
			updateThing: (id, newName) => firebase.firestore().collection('Things').doc(id)
				.update({ name: newName })
				.then(()=> console.log('updated'))
				.catch((e) => console.log("error updating ", id)),
		}
		
		// mithril
		const Mithril_App = {
			oncreate: () => {
				FBObserve( 'Things', State.things )
			},
			view: function(){
				return [
					, m('h2', 'Mithril')
					, m('button', { onclick: State.addThing.bind(null, 'Things') }, '+ new thing')
					, State.things.map((thing) =>
						m('.thing'
							, { key: thing.id }
							, m('input[type=text]'
								, {
									value: thing.data.name,
									onblur: m.withAttr('value', (v) => State.updateThing(thing.id, v))
								}
							)
							, m('button', { onclick: State.removeThing.bind(null, thing.id) }, 'x')
						)
					)
				]
			}
		}
		
		// react
		const redrawReact = () => ReactDOM.render(<React_App />, document.getElementById('react'))
		class OnChange_Input extends React.Component {
			state = { typed: this.props.obj.data.name }
			componentWillReceiveProps(props){
				this.setState({ typed: props.obj.data.name })
			}
			onInput(e){	this.setState({ typed: e.target.value }) }
			onBlur(e){
				State.updateThing(this.props.obj.id, e.target.value)
			}
			render() {
				return <input type="text" 
				              value={ this.state.typed } 
				              onInput={ this.onInput.bind(this) } 
				              onBlur={ this.onBlur.bind(this) } />
			}
		}
		class React_App extends React.Component {
			componentDidMount(){
				FBObserve( 'Things', State.things, { redrawFn: redrawReact } )
			}
			render(){
				return <div>
					<h2>React</h2>
					<button onClick={ State.addThing.bind(null, 'Things') }>+ new thing</button>
					{ State.things.map((thing) => {
						return <div className="thing" key="{thing.id}">
							<OnChange_Input obj={thing} />
							<button onClick={ State.removeThing.bind(null, thing.id) }>x</button>
						</div>
					}) }
				</div>
			}
		}

		// vanilla
		(function () {
			const vanilla = document.getElementById('vanilla')
			const h2 = document.createElement('h2')
			h2.textContent = 'Vanilla'
			vanilla.appendChild(h2)
			const addButton = document.createElement('button')
			addButton.textContent = '+ new thing'
			addButton.onclick = State.addThing.bind(null, 'Things')
			vanilla.appendChild(addButton)
			const wrapper = document.createElement('div')
			vanilla.appendChild(wrapper)
			
			const updateTheView = () => {
				wrapper.innerHTML = ''
				State.things.forEach((thing) => {
					const el = document.createElement('div')
					el.className = 'thing'
					const input = document.createElement('input')
					input.type = 'text'
					input.value = thing.data.name
					input.onchange = (e) => State.updateThing(thing.id, e.target.value)
					el.appendChild(input)
					const deleter = document.createElement('button')
					deleter.textContent = 'x'
					deleter.onclick = State.removeThing.bind(null, thing.id)
					el.appendChild(deleter)
					wrapper.appendChild(el)
				})
			}
			FBObserve( 'Things', State.things, { redrawFn: updateTheView } )
			window.renderVanilla = updateTheView
		})()
		
		// get everybody home
		m.mount(document.getElementById('mithril'), Mithril_App)
		redrawReact()
		renderVanilla()
	</script>
</body>
</html>
